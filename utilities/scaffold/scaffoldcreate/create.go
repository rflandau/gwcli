// A create action creates a shallow list of inputs for the user to fill via flags or interactive
// TIs before being passed back to the progenitor to transform into usable data for their create
// function.
//
// The available fields are fairly configurable, the progentior provides their own map of Field
// structs, and easily extensible, the struct can have more options or formats bolted on without too
// much trouble.
//
// This scaffold is a bit easier to extend than Delete and List, given it did not require generics.
//
// Look to the scheduled query creation action (external to the one built into DataScope) as a good
// example.
//
// ! Once a Config is given by the caller, it should be considered ReadOnly.
//
// NOTE: More complex creation with nested options and mutli-stage flows should be built
// independently. This scaffold is intended for simple, handful-of-field creations.
package scaffoldcreate

import (
	"fmt"
	"gwcli/action"
	"gwcli/clilog"
	"gwcli/stylesheet"
	"gwcli/treeutils"
	"strings"
	"sync"

	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

const (
	errMissingRequiredFlags = "missing required flags %v"
)

// keys -> Field; used as (ReadOnly) configuration for this creation instance
type Config = map[string]Field

// signature the supplied creation function must match
type CreateFunc func(cfg Config, values map[string]string) (id any, invalid string, err error)

func NewCreateAction(aliases []string, singular string,
	fields Config,
	create CreateFunc) action.Pair {
	// pull flags from provided fields
	//const mappedString = "mapped field %v (key: %v) to %v flag %v"
	var flags pflag.FlagSet = installFlagsFromFields(fields)

	cmd := treeutils.NewActionCommand(
		"create",
		"create a "+singular,
		"create a new "+singular,
		aliases,
		func(c *cobra.Command, s []string) {
			// get standard flags
			_, err := c.Flags().GetBool("script")
			if err != nil {
				clilog.Tee(clilog.ERROR, c.ErrOrStderr(), err.Error()+"\n")
				return
			}
			// get field flags
			var values map[string]string
			if vals, mr, err := getValuesFromFlags(c.Flags(), fields); err != nil {
				clilog.Tee(clilog.ERROR, c.ErrOrStderr(), err.Error()+"\n")
				return
			} else if mr != nil {
				fmt.Fprintf(c.OutOrStdout(), errMissingRequiredFlags+"\n", mr)
				return
			} else {
				values = vals
			}

			// attempt to create the new X
			if id, inv, err := create(fields, values); err != nil {
				clilog.Tee(clilog.ERROR, c.ErrOrStderr(), err.Error()+"\n")
				return
			} else if inv != "" { // some of the flags were invalid
				fmt.Fprintln(c.OutOrStdout(), inv)
				return
			} else {
				fmt.Fprintf(c.OutOrStdout(), "Successfully created %v (ID: %v).", singular, id)
			}
		})

	// attach mined flags to cmd
	cmd.Flags().AddFlagSet(&flags)

	return treeutils.GenerateAction(cmd, newCreateModel(fields, singular, create))
}

//#region Field

type FieldType = string

const (
	Text FieldType = "text"
)

// A field defines a single data point that will be passed to the create function.
type Field struct {
	Required     bool      // this field must be populated prior to calling createFunc
	Title        string    // field name displayed next to prompt and as flage name
	Usage        string    // flag usage displayed via -h
	Type         FieldType // type of field, dictating how it is presented to the user
	FlagName     string    // auto-generated by NewField, but can be overwritten
	DefaultValue string    // default flag and TI value

	// values specific to interactive usage
	TI struct {
		Placeholder string // defaults to '(optional)' if unset and !Field.Required
		// validator to run each each time an input is keyed into the TI.
		//
		// this validator is run constantly in interactive mode, so it should be lightweight.
		//
		// whole string validation is left to the createFunc.
		Validator func(s string) error
	}
}

// Returns a new field with only the required fields. Defaults to a Text type.
//
// You can build a Field manually, w/o NewField, but make sure you call
// .DeriveFlagName() if you do not supply one.
func NewField(req bool, Title string) Field {
	f := Field{Required: req, Title: Title, Type: Text, FlagName: DeriveFlagName(Title)}
	return f
}

func DeriveFlagName(title string) string {
	return strings.Replace(title, " ", "-", -1)
}

// Returns a FlagSet built from the given flagmap
func installFlagsFromFields(fields Config) pflag.FlagSet {
	var flags pflag.FlagSet
	for _, f := range fields {
		// map fields to their flags
		switch f.Type {
		case Text:
			flags.String(
				f.FlagName,
				f.DefaultValue, // default flag value
				f.Usage)
		default:
			panic("developer error: unknown field type: " + f.Type)
		}
	}

	return flags
}

// Given a parsed flagset and the fiel configuration, builds a corollary map of field values.
//
// Returns the values for each flag (default if unset), a list of required fields (as their flag
// names) that were not set, and an error (if one occurred).
func getValuesFromFlags(fs *pflag.FlagSet, fields Config) (
	values map[string]string, missingRequireds []string, err error,
) {
	values = make(map[string]string)
	for k, f := range fields {
		switch f.Type {
		case Text:

			flagVal, err := fs.GetString(f.FlagName)
			if err != nil {
				return nil, nil, err
			}
			clilog.Writer.Debugf("flag %v changed? %v", f.FlagName, fs.Changed(f.FlagName))
			// if this value is required, but unset, add it to the list
			if f.Required && !fs.Changed(f.FlagName) {
				missingRequireds = append(missingRequireds, f.FlagName)
			}

			values[k] = flagVal
		default:
			panic("developer error: unknown field type: " + f.Type)
		}
		// resave the updated field value back into the map for later use
		fields[k] = f
	}
	return values, missingRequireds, nil
}

//#endregion

//#region interactive mode (model) implementation

type mode uint // state of the interactive application

const (
	inputting mode = iota
	quitting
)

// interactive model that builds out inputs based on the read-only Config supplied on creation.
type createModel struct {
	mode mode

	singular string // "macro", "search", etc

	fields Config // RO configuration provided by the caller

	// Ordered array of map keys, defines order in which fields are displayed.
	// Set on newCreate.
	keyOrder []string

	tis map[string]textinput.Model // key -> field's TI, if it exists

	fs pflag.FlagSet // parsed flag values, mined from the Config
	cf CreateFunc    // function to create the new entity
}

func newCreateModel(fields Config, singular string, cf CreateFunc) *createModel {
	c := &createModel{
		mode:     inputting,
		singular: singular,
		fields:   fields,
		tis:      make(map[string]textinput.Model),
		cf:       cf,
	}

	// TODO add support for custom ordering
	for k, v := range fields {
		// generate the key order
		c.keyOrder = append(c.keyOrder, k)
		// generate the TI for the field
		c.tis[k] = stylesheet.NewTI(v.DefaultValue, !v.Required)
	}

	return c
}

func (c *createModel) Update(msg tea.Msg) tea.Cmd {
	// TODO
	return nil
}

// Iterates through the keymap, drawing each ti and title in key key order
func (c *createModel) View() string {
	var sb strings.Builder

	for _, key := range c.keyOrder {
		// pair titles and their TIs
		sb.WriteString(c.fields[key].Title + ": " + c.tis[key].View() + "\n")
	}

	// may need to chomp the last newline

	return sb.String()
}

func (c *createModel) Done() bool {
	return c.mode == quitting
}

func (c *createModel) Reset() error {
	c.mode = inputting

	var wg sync.WaitGroup
	wg.Add(2)
	// reset TIs
	go func() {
		for k, ti := range c.tis {
			ti.Reset()
			c.tis[k] = ti
		}
		wg.Done()
	}()

	// refresh flags to their original, unparsed and unvalued state
	go func() { c.fs = installFlagsFromFields(c.fields); wg.Done() }()

	wg.Wait()
	return nil
}

func (c *createModel) SetArgs(_ *pflag.FlagSet, tokens []string) (
	invalid string, onStart []tea.Cmd, err error,
) {
	if err := c.fs.Parse(tokens); err != nil {
		return "", nil, err
	}

	if flagVals, mr, err := getValuesFromFlags(&c.fs, c.fields); err != nil {
		return "", nil, err
	} else if mr != nil {
		return fmt.Sprintf(errMissingRequiredFlags+"\n", mr), nil, nil
	} else {
		// set flag values as the starter values in their corresponding TI
		for k, v := range flagVals {
			ti := c.tis[k]
			ti.SetValue(v)
			c.tis[k] = ti // iirc TIs are not reference types, so this is requires // TODO test this
		}
	}

	return "", nil, nil
}

//#endregion

/*
Creates needs to know the fields to present to a user for population.
For each field, we need to know:
1. field name
2. optional or required?
3. corresponding flag for non-interactive input
4. an optional validation function
We need to be able to pass populated fields, once all requireds are filled,
back to the implementation to contort and pass to a create function.
This create function must be able to return an error and, ideally,
a string validation error.
However, we cannot pre-declare the function signature until we know how the
create data will be stored.

Field likely need to be stored in a map (string -> struct).
This will also allow me to bolt additional features onto the struct easily.
*/
