// A create action creates a shallow list of inputs for the user to fill via flags or interactive
// TIs before being passed back to the progenitor to transform into usable data for their create
// function.
//
// The available fields are fairly configurable, the progentior provides their own map of Field
// structs, and easily extensible, the struct can have more options or formats bolted on without too
// much trouble.
//
// This scaffold is a bit easier to extend than Delete and List, given it did not require generics.
//
// Look to the scheduled query creation action (external to the one built into DataScope) as a good
// example.
//
// ! Once a Config is given by the caller, it should be considered ReadOnly.
//
// NOTE: More complex creation with nested options and mutli-stage flows should be built
// independently. This scaffold is intended for simple, handful-of-field creations.
package scaffoldcreate

import (
	"fmt"
	"gwcli/action"
	"gwcli/clilog"
	"gwcli/mother"
	"gwcli/stylesheet"
	"gwcli/stylesheet/colorizer"
	"gwcli/treeutils"
	"os"
	"strings"
	"sync"

	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/x/term"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

const (
	errMissingRequiredFlags = "missing required flags %v"
	createdSuccessfully     = "Successfully created %v (ID: %v)."
)

// #region local styles
var (
	tiFieldRequiredSty = stylesheet.Header1Style
	tiFieldOptionalSty = stylesheet.Header2Style
)

//#endregion

// keys -> Field; used as (ReadOnly) configuration for this creation instance
type Config = map[string]Field

type Values = map[string]string

// signature the supplied creation function must match
type CreateFunc func(cfg Config, values Values) (id any, invalid string, err error)

func NewCreateAction(aliases []string, singular string,
	fields Config,
	create CreateFunc) action.Pair {
	// pull flags from provided fields
	//const mappedString = "mapped field %v (key: %v) to %v flag %v"
	var flags pflag.FlagSet = installFlagsFromFields(fields)

	cmd := treeutils.NewActionCommand(
		"create",
		"create a "+singular,
		"create a new "+singular,
		aliases,
		func(c *cobra.Command, s []string) {
			// get standard flags
			script, err := c.Flags().GetBool("script")
			if err != nil {
				clilog.Tee(clilog.ERROR, c.ErrOrStderr(), err.Error()+"\n")
				return
			}
			// get field flags
			var values map[string]string
			if vals, mr, err := getValuesFromFlags(c.Flags(), fields); err != nil {
				clilog.Tee(clilog.ERROR, c.ErrOrStderr(), err.Error()+"\n")
				return
			} else if mr != nil {
				if !script {
					if err := mother.Spawn(c.Root(), c, s); err != nil {
						clilog.Writer.Critical(err.Error())
					}
					return
				} else {
					fmt.Fprintf(c.OutOrStdout(), errMissingRequiredFlags+"\n", mr)
				}
				return
			} else {
				values = vals
			}

			// attempt to create the new X
			if id, inv, err := create(fields, values); err != nil {
				clilog.Tee(clilog.ERROR, c.ErrOrStderr(), err.Error()+"\n")
				return
			} else if inv != "" { // some of the flags were invalid
				fmt.Fprintln(c.OutOrStdout(), inv)
				return
			} else {
				fmt.Fprintf(c.OutOrStdout(), "Successfully created %v (ID: %v).", singular, id)
			}
		})

	// attach mined flags to cmd
	cmd.Flags().AddFlagSet(&flags)

	return treeutils.GenerateAction(cmd, newCreateModel(fields, singular, create))
}

// Given a parsed flagset and the field configuration, builds a corollary map of field values.
//
// Returns the values for each flag (default if unset), a list of required fields (as their flag
// names) that were not set, and an error (if one occurred).
func getValuesFromFlags(fs *pflag.FlagSet, fields Config) (
	values Values, missingRequireds []string, err error,
) {
	values = make(Values)
	for k, f := range fields {
		switch f.Type {
		case Text:

			flagVal, err := fs.GetString(f.FlagName)
			if err != nil {
				return nil, nil, err
			}
			clilog.Writer.Debugf("flag %v changed? %v", f.FlagName, fs.Changed(f.FlagName))
			// if this value is required, but unset, add it to the list
			if f.Required && !fs.Changed(f.FlagName) {
				missingRequireds = append(missingRequireds, f.FlagName)
			}

			values[k] = flagVal
		default:
			panic("developer error: unknown field type: " + f.Type)
		}
	}
	return values, missingRequireds, nil
}

//#region Field

type FieldType = string

const (
	Text FieldType = "text"
)

// A field defines a single data point that will be passed to the create function.
type Field struct {
	Required     bool      // this field must be populated prior to calling createFunc
	Title        string    // field name displayed next to prompt and as flage name
	Usage        string    // flag usage displayed via -h
	Type         FieldType // type of field, dictating how it is presented to the user
	FlagName     string    // auto-generated by NewField, but can be overwritten
	DefaultValue string    // default flag and TI value

	// values specific to interactive usage
	TI struct {
		Placeholder string // defaults to '(optional)' if unset and !Field.Required
		// validator to run each each time an input is keyed into the TI.
		//
		// this validator is run constantly in interactive mode, so it should be lightweight.
		//
		// whole string validation is left to the createFunc.
		Validator func(s string) error
	}
}

// Returns a new field with only the required fields. Defaults to a Text type.
//
// You can build a Field manually, w/o NewField, but make sure you call
// .DeriveFlagName() if you do not supply one.
func NewField(req bool, Title string) Field {
	f := Field{Required: req, Title: Title, Type: Text, FlagName: DeriveFlagName(Title)}
	return f
}

func DeriveFlagName(title string) string {
	return strings.Replace(title, " ", "-", -1)
}

// Returns a FlagSet built from the given flagmap
func installFlagsFromFields(fields Config) pflag.FlagSet {
	var flags pflag.FlagSet
	for _, f := range fields {
		// map fields to their flags
		switch f.Type {
		case Text:
			flags.String(
				f.FlagName,
				f.DefaultValue, // default flag value
				f.Usage)
		default:
			panic("developer error: unknown field type: " + f.Type)
		}
	}

	return flags
}

//#endregion

//#region interactive mode (model) implementation

const defaultWidth = 80

type mode uint // state of the interactive application

const (
	inputting mode = iota
	quitting
)

// interactive model that builds out inputs based on the read-only Config supplied on creation.
type createModel struct {
	mode mode

	width int // tty width

	singular string // "macro", "search", etc

	fields Config // RO configuration provided by the caller

	// Ordered array of map keys, defines order in which fields are displayed.
	// Set on newCreate. Shares indices with tis
	keyOrder []string
	selected uint              // currently focused ti (in key order index)
	tis      []textinput.Model // text inputs. Use keyOrder to map to fields

	inputErr  string // the reason inputs are invalid
	createErr string // the reason the last create failed (not for invalid parameters)

	fs pflag.FlagSet // parsed flag values, mined from the Config
	cf CreateFunc    // function to create the new entity
}

func newCreateModel(fields Config, singular string, cf CreateFunc) *createModel {
	c := &createModel{
		mode:     inputting,
		width:    defaultWidth,
		singular: singular,
		fields:   fields,
		tis:      make([]textinput.Model, 0),
		fs:       installFlagsFromFields(fields),
		cf:       cf,
	}

	// TODO add support for custom ordering
	for k, v := range fields {
		// generate the key order
		c.keyOrder = append(c.keyOrder, k)
		// generate the TI for the field
		ti := stylesheet.NewTI(v.DefaultValue, !v.Required)
		ti.Validate = v.TI.Validator
		ti.Placeholder = v.TI.Placeholder
		c.tis = append(c.tis, ti)
	}

	if len(c.tis) > 0 {
		c.tis[0].Focus()
	}

	return c
}

func (c *createModel) Update(msg tea.Msg) tea.Cmd {
	if c.mode == quitting {
		return nil
	}
	if keyMsg, ok := msg.(tea.KeyMsg); ok {
		c.inputErr = "" // clear last input error
		switch keyMsg.Type {
		case tea.KeyUp, tea.KeyTab:
			c.focusPrevious()
			return textinput.Blink
		case tea.KeyDown, tea.KeyShiftTab:
			c.focusNext()
			return textinput.Blink
		case tea.KeyEnter:
			if keyMsg.Alt { // only submit on alt+enter
				c.createErr = "" // clear last error
				// extract values from TIs
				values, mr := c.extractValuesFromTIs()
				if mr != nil {
					c.inputErr = fmt.Sprintf("%v are required", mr)
					return nil
				}
				id, invalid, err := c.cf(c.fields, values)
				if err != nil {
					c.createErr = err.Error()
				} else if invalid != "" {
					c.inputErr = invalid
					return nil
				}
				// done, die
				c.mode = quitting
				return tea.Println(fmt.Sprintf(createdSuccessfully, c.singular, id))
			}
		}
	} else if sizeMsg, ok := msg.(tea.WindowSizeMsg); ok {
		c.width = sizeMsg.Width
		return nil
	}
	// pass message to currently focused ti
	var cmd tea.Cmd
	c.tis[c.selected], cmd = c.tis[c.selected].Update(msg)
	return cmd
}

func (c *createModel) focusNext() {
	c.tis[c.selected].Blur()
	c.selected += 1
	if c.selected >= uint(len(c.tis)) { // jump to start
		c.selected = 0
	}
	c.tis[c.selected].Focus()
}

func (c *createModel) focusPrevious() {
	c.tis[c.selected].Blur()
	if c.selected == 0 { // jump to end
		c.selected = uint(len(c.tis)) - 1
	} else {
		c.selected -= 1
	}
	c.tis[c.selected].Focus()
}

// Generates the corrollary value map from the TIs.
//
// Returns the values for each TI (mapped to their Config key), a list of required fields (as their
// field.Title names) that were not set, and an error (if one occured).
func (c *createModel) extractValuesFromTIs() (
	values Values, missingRequireds []string,
) {
	values = make(Values)
	for i, k := range c.keyOrder {
		val := strings.TrimSpace(c.tis[i].Value())
		field := c.fields[k]
		if val == "" && field.Required {
			missingRequireds = append(missingRequireds, field.Title)
		}

		values[k] = val
	}

	return values, missingRequireds
}

// Iterates through the keymap, drawing each ti and title in key key order
func (c *createModel) View() string {
	var sb strings.Builder

	for i, key := range c.keyOrder {
		var title string
		if c.fields[key].Required {
			title = tiFieldRequiredSty.Render(c.fields[key].Title + ": ")
		} else {
			title = tiFieldOptionalSty.Render(c.fields[key].Title + ": ")

		}
		// pair titles and their TIs
		sb.WriteString(
			title + c.tis[i].View() + "\n",
		)
		// TODO wrap TIs to newline if window width is < longest title width+TI width
	}

	// display errors, if they exist
	// note: result will always be an error string, as we exit on success
	sb.WriteString(colorizer.SubmitString("alt+enter", c.inputErr, c.createErr, c.width))

	return sb.String()
}

func (c *createModel) Done() bool {
	return c.mode == quitting
}

func (c *createModel) Reset() error {
	c.mode = inputting

	var wg sync.WaitGroup
	wg.Add(2)
	// reset TIs
	go func() {
		for i := range c.tis {
			c.tis[i].Reset()
			c.tis[i].Blur()
		}
		wg.Done()
	}()
	// refresh flags to their original, unparsed and unvalued state
	go func() { c.fs = installFlagsFromFields(c.fields); wg.Done() }()

	wg.Wait()

	c.createErr = ""
	c.inputErr = ""
	c.selected = 0
	if len(c.tis) > 0 {
		c.tis[0].Focus()
	}
	return nil
}

func (c *createModel) SetArgs(_ *pflag.FlagSet, tokens []string) (
	invalid string, onStart []tea.Cmd, err error,
) {
	if err := c.fs.Parse(tokens); err != nil {
		return "", nil, err
	}

	// we do not need to check missing requires when run from mother
	if flagVals, _, err := getValuesFromFlags(&c.fs, c.fields); err != nil {
		return "", nil, err
	} else {
		// set flag values as the starter values in their corresponding TI
		for i, k := range c.keyOrder {
			c.tis[i].SetValue(flagVals[k])
		}
	}

	return "", []tea.Cmd{fetchWindowSize}, nil
}

// Queries for avaialble window size so we can wrap text by width, once this arrives.
// NOTE: width and height are returned, but create only uses width.
func fetchWindowSize() tea.Msg {
	w, h, err := term.GetSize(os.Stdin.Fd())
	if err != nil {
		clilog.Writer.Errorf("Failed to fetch terminal size: %v", err)
	}
	return tea.WindowSizeMsg{Width: w, Height: h}
}

//#endregion

/*
Creates needs to know the fields to present to a user for population.
For each field, we need to know:
1. field name
2. optional or required?
3. corresponding flag for non-interactive input
4. an optional validation function
We need to be able to pass populated fields, once all requireds are filled,
back to the implementation to contort and pass to a create function.
This create function must be able to return an error and, ideally,
a string validation error.
However, we cannot pre-declare the function signature until we know how the
create data will be stored.

Field likely need to be stored in a map (string -> struct).
This will also allow me to bolt additional features onto the struct easily.
*/
