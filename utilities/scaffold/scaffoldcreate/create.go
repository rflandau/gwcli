package scaffoldcreate

import (
	"fmt"
	"gwcli/action"
	"gwcli/clilog"
	"gwcli/treeutils"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

// keys mapped to their fields, how the set is usually passed around and required
type FieldMap = map[string]Field

// signature the supplied creation function must match
type CreateFunc func(FieldMap) (id any, invalid string, err error)

func NewCreateAction(aliases []string, singular string,
	fields FieldMap,
	create CreateFunc) action.Pair {
	// pull flags from provided fields
	//const mappedString = "mapped field %v (key: %v) to %v flag %v"
	var flags pflag.FlagSet = installFlagsFromFields(fields)

	cmd := treeutils.NewActionCommand(
		"create",
		"create a "+singular,
		"create a new "+singular,
		aliases,
		func(c *cobra.Command, s []string) {
			// get standard flags
			_, err := c.Flags().GetBool("script")
			if err != nil {
				clilog.Tee(clilog.ERROR, c.ErrOrStderr(), err.Error()+"\n")
				return
			}
			// get field flags
			if mr, err := updateFieldsFromFlags(c.Flags(), fields); err != nil {
				clilog.Tee(clilog.ERROR, c.ErrOrStderr(), err.Error()+"\n")
				return
			} else if mr != nil {
				fmt.Fprintf(c.OutOrStdout(), "missing required flags %v\n", mr)
				return
			}

			// attempt to create the new X
			if id, inv, err := create(fields); err != nil {
				clilog.Tee(clilog.ERROR, c.ErrOrStderr(), err.Error()+"\n")
				return
			} else if inv != "" { // some of the flags were invalid
				fmt.Fprintln(c.OutOrStdout(), inv)
				return
			} else {
				fmt.Fprintf(c.OutOrStdout(), "Successfully created %v (ID: %v).", singular, id)
			}
		})

	// attach mined flags to cmd
	cmd.Flags().AddFlagSet(&flags)

	return treeutils.GenerateAction(cmd, nil)
}

//#region Field

type FieldType = string

const (
	Text FieldType = "text"
)

// A field defines a single data point that will be passed to the create function.

type Field struct {
	Required bool      // this field must be populated prior to calling createFunc
	Title    string    // field name displayed next to prompt and as flage name
	Usage    string    // flag usage displayed via -h
	Type     FieldType // type of field, dictating how it is presented to the user
	FlagName string    // auto-generated by NewField, but can be overwritten
	// default value if set on creation; updated to user input when returned
	Value string

	// values specific to interactive usage
	TI struct {
		Placeholder string // defaults to '(optional)' if unset and !Field.Required
		// validator to run each each time an input is keyed into the TI.
		//
		// this validator is run constantly in interactive mode, so it should be lightweight.
		//
		// whole string validation is left to the createFunc.
		Validator func(s string) error
	}
}

// Returns a new field with only the required fields. Defaults to a Text type.
//
// You should use NewField and then set the rest of the fields in the returned struct, rather than
// instantiating a struct directly.
func NewField(req bool, Title string) Field {
	f := Field{Required: req, Title: Title, Type: Text}
	f.FlagName = strings.Replace(f.Title, " ", "-", -1)
	return f
}

// Returns a FlagSet built from the given flagmap
func installFlagsFromFields(fields FieldMap) pflag.FlagSet {
	var flags pflag.FlagSet
	for _, f := range fields {
		// map fields to their flags
		switch f.Type {
		case Text:
			flags.String(
				f.FlagName,
				f.Value, // default flag value
				f.Usage)
		default:
			panic("developer error: unknown field type: " + f.Type)
		}
	}

	return flags
}

// Given a parsed flagset and the initial field map, sets flag values to their corresponding field values.
//
// All required flags that are not set are returned as a slice of their flag names.
//
// ! Destructively alters the .Value fields in the FieldMap
func updateFieldsFromFlags(fs *pflag.FlagSet, fields FieldMap) (missingRequireds []string, err error) {
	for k, f := range fields {
		switch f.Type {
		case Text:

			flagVal, err := fs.GetString(f.FlagName)
			if err != nil {
				return nil, err
			}
			clilog.Writer.Debugf("flag %v changed? %v", f.FlagName, fs.Changed(f.FlagName))
			// if this value is required, but unset, add it to the list
			if f.Required && !fs.Changed(f.FlagName) {
				missingRequireds = append(missingRequireds, f.FlagName)
				continue
			}

			f.Value = flagVal
		default:
			panic("developer error: unknown field type: " + f.Type)
		}
		// resave the updated field value back into the map for later use
		fields[k] = f
	}
	return missingRequireds, nil
}

//#endregion

//#region interactive mode (model) implementation

type mode uint // state of the interactive application

const (
	inputting mode = iota
	quitting
)

type createModel struct {
	mode mode

	singular string
}

//#endregion

/*
Creates needs to know the fields to present to a user for population.
For each field, we need to know:
1. field name
2. optional or required?
3. corresponding flag for non-interactive input
4. an optional validation function
We need to be able to pass populated fields, once all requireds are filled,
back to the implementation to contort and pass to a create function.
This create function must be able to return an error and, ideally,
a string validation error.
However, we cannot pre-declare the function signature until we know how the
create data will be stored.

Field likely need to be stored in a map (string -> struct).
This will also allow me to bolt additional features onto the struct easily.
*/
